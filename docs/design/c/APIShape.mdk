### Client interface {#clang-apisurface-serviceclient}

In C, your API surface will consist of one or more _service client initializers_ that the consumer will call to define a connection to your service, plus a set of supporting functions that perform network requests.

~ Must {#clang-apisurface-serviceclientnaming}
name the service client initializer `az_shortname_create_client()`.  It should return a type (generally a struct or struct pointer, but it could also be an integer orhandle that you deal with internally) or `NULL` on error.
~

~ Must {#clang-apisurface-serviceclientclosing}
allow the consumer to release resources by calling `az_shortname_close_client()`.  This allows the library to manage memory on behalf of the user for the purposes of the client as well.
~

~ Must {#clang-apisurface-serviceclient-types}
define a type `az_shortname_client` that represents the response from the service client initializer.
~

A typical definition might look like:

Header file:

```c
#ifndef KEYVAULT_CLIENT_H
#define KEYVAULT_CLIENT_H

typedef struct az_keyvault_client az_keyvault_client;
typedef struct az_keyvault_client_credentials az_keyvault_client_credentials;
typedef struct az_keyvault_http_handler_pipeline az_keyvault_http_handler_pipeline;

az_keyvault_client *az_keyvault_create_client();
void az_keyvault_close_client(az_keyvault_client *client);


/* C does not support overloading function names, so we use a different name */
az_keyvault_client *az_keyvault_create_client_with_credentials(az_keyvault_client_credentials *credentials);

/* Other functions related to kevault client */
int az_keyvault_client_backup_certificate_With_http_messages(char *vault_base_url, char *certificate_name, char **custom_headers, int headers_count);

/* client used to create other types */
az_keyvault_http_handler_pipeline *az_keyvault_client_create_http_handler_pipeline(az_http_client_handler *handler);
void az_keyvault_client_close_http_handler_pipeline(az_keyvault_http_handler_pipeline *handler_pipeline);

#endif /* IOT_CLIENT_API_H */
```

Source file:

```c
#include <stdbool.h> 
#include <stddef.h>
/* for az_http_client_handler*/
#include "http_client.h"
#include "keyvault_client.h"

typedef struct az_keyvault_client {
	char *accept_language;
	char *api_version;
	az_keyvault_client_credentials *credentials;
	bool generate_clientrequest_id;
	int long_running_operation_retry_timeout;
	char *vault_without_scheme;
} az_keyvault_client;

typedef struct az_keyvault_client_credentials {
	char *version;
	/* remaining struct members here */
} az_keyvault_client_credentials;

typedef struct az_keyvault_http_handler_pipeline {
	char *version;
	/* remaining struct members here */
} az_keyvault_http_handler_pipeline;

az_keyvault_client *az_keyvault_create_client() {
	/* implementation */
	return NULL;
}

void az_keyvault_close_client(az_keyvault_client *client)
{
	/* implementation */
}

az_keyvault_client *az_keyvault_create_client_with_credentials(az_keyvault_client_credentials *credentials) {
	/* implementation */
	return NULL;
}

int az_keyvault_client_backup_certificate_With_http_messages(char *vault_base_url, char *certificate_name, char **custom_headers, int headers_count)
{
	/* implementation */
	return 0;
}

az_keyvault_http_handler_pipeline* az_keyvault_client_create_http_handler_pipeline(az_http_client_handler *handler)
{
	/* implementation */
	return NULL;
}

void az_keyvault_client_close_http_handler_pipeline(az_keyvault_http_handler_pipeline *handler_pipeline)
{
	/* implementation */
}
```

~ ToDo
Please note that in the previous examples, the memory model used is to have it allocated by the callee, rather than the caller. There are different options and this will be discussed further in a separate memory management section.
~

~ Must {#clang-apisurface-serviceclientconstructor}
allow the consumer to construct a service client with the minimal information needed to connect and authenticate to the service.
~

~ Must {#clang-apisurface-standardized-verbs}
standardize verb prefixes within a set of client libraries for a service.  The service must be able to speak about a specific operation in a cross-language manner within outbound materials (such as documentation, blogs, and public speaking).
They cannot do this if the same operation is referred to by different verbs in different languages.  The following verbs are preferred for CRUD operations:

|Verb|Parameters|Returns|Comments|
|-|-|-|-|
| az\_\<shortname>\_\<objname>\__insert_\_\<noun>|key, item|Updated or created item|Create new item or update existing item. Verb is primarily used in database-like services |
| az\_\<shortname>\_\<objname>\__set_\_\<noun>|key, item|Updated or created item|Create new item or update existing item. Verb is primarily used for dictionary-like properties of a service |
| az\_\<shortname>\_\<objname>\__create_\_\<noun>|key, item|Created item|Create new item. Fails if item already exists. |
| az\_\<shortname>\_\<objname>\__update_\_\<noun>|key, partial item|Updated item|Fails if item does not exist. |
| az\_\<shortname>\_\<objname>\__replace_\_\<noun>|key, item|Replace existing item|Completely replaces an existing item. Fails if the item does not exist. |
| az\_\<shortname>\_\<objname>\__delete_\_\<noun>|key|None|Delete an existing item. Will succeed even if item did not exist. |
| az\_\<shortname>\_\<objname>\__append_\_\<noun>|item|Appended item|Add item to a collection. Item will be added last. |
| az\_\<shortname>\_\<objname>\__add_\_\<noun>|index, item|Added item|Add item to a collection. Item will be added on the given position. |
| az\_\<shortname>\_\<objname>\__remove_\_\<noun>|key|None or removed item|Remove item from a collection. |
| az\_\<shortname>\_\<objname>\__get_\_\<noun>|key|Item|Will return None if item does not exist |
| az\_\<shortname>\_\<objname>\__list_\_\<noun>||array of items|Return list of items. Returns empty list if no items exist |
| az\_\<shortname>\_\<objname>\__exists_\_\<noun>|key|boolean|Return True if the item exists. |

~

Some examples:
```c
void az_keyvault_client_delete_key(az_keyvault_client *client, char *vault_base_url, char *key_name);
void az_keyvault_client_delete_key_async(az_keyvault_client *client, char *vault_base_url, char *key_name, az_keyvault_callback *callback, void *callback_context);

az_keyvault_certificate_bundle *az_keyvault_client_get_certificate(az_keyvault_client *client, char *certtificate_id);
void az_keyvault_client_get_certificate_async(az_keyvault_client *client, char *certtificate_id, az_keyvault_callback *callback, void *callback_context);

bool az_keyvault_client_exists_key(az_keyvault_client *client, char *key_name);
```

~ Must {#clang-apisurface-lro-initiation}
prefer the use of the following terms for long running operations:

`    az_<shortname>_<objname>_begin_<verb>_<noun>` for methods that initiate a long running operation.  Example `az_storage_blob_begin_copy_from_url()`.
~

~ Must {#clang-apisurface-supportallfeatures}
support as close as possible to 100% of the commonly used features provided by the Azure service the client library represents.  Unlike more general purpose object-orientated languages, the scenarios that need to be supported in C are more limited.
~

### Network requests

Since the client library clangly wraps one or more HTTP requests, it is important to support standard network capabilities.  Asynchronous programming techniques are not widely understood and the low level nature of C provides an indication
that consumers may want to manage threads themselves.  Many developers prefer synchronous method calls for their easy semantics when learning how to use a technology.  

~ Must {#clang-apisurface-be-thread-safe}
be thread-safe.  Individual requests to the service must be able to be placed on separate threads without unintentional problems.
~

~ Must {#clang-apisurface-syncandasync}
support both synchronous and asynchronous functions, utilizing `libuv` for async support.  
~

~ Must {#clang-apisurface-identifyasync}
ensure that the consumer can easily identify which functions are async and which are synchronous.
~

When an application makes a network request, the network infrastructure (like routers) and the called service may take a long time to respond and, in fact, may never respond. A well-written application SHOULD NEVER give up its control to
the network infrastucture or service. 

~ Must {#clang-apisurface-supportcancellation}
accept a timeout in milliseconds for each network request.  
~

~ MustNot {#clang-apisurface-no-leaking-implementation}
leak the underlying protocol transport implementation details to the consumer.  All types from the protocol transport implementation must be appropriately abstracted.
~

### Authentication

Azure services use a variety of different authentication schemes to allow clients to access the service.  Conceptually, there are two entities responsible in this process: a credential and an authentication policy. 
Credentials provide confidential authentication data.  Authentication policies use the data provided by a credential to authenticate requests to the service.  

~ Must {#clang-apisurface-support-all-auth-techniques}
support all authentication techniques that the service supports and are available to a client application (as opposed to service side).  C is used only for client applications when talking to Azure, so some authentication techniques may not be valid.
~

~ Must {#clang-apisurface-use-azure-core}
use credential and authentication policy implementations from the Azure Core library where available.
~

~ Must {#clang-apisurface-prefer-token-auth}
provide credential types that can be used to fetch all data needed to authenticate a request to the service in a non-blocking atomic manner for each authentication scheme that does not have an implementation in Azure Core.
~

~ Must {#clang-apisurface-auth-in-constructors}
provide service client constructors or factories that accept any supported authentication credentials.
~

Client libraries may support providing credential data via a connection string __ONLY IF__ the service provides a connection string to users via the portal or other tooling. 

~ MustNot {#clang-apisurface-no-connection-strings}
support constructing a service client with a connection string unless such connection string is available within tooling (for copy/paste operations).
~
