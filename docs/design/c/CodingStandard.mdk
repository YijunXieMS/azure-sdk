# C coding standards

The following coding standards have been adopted to ensure consistency and readability across all client libraries.

## Files

~ Must
use standard extensions for files.  Use the `.h` extension for header files and `.c` for source files.
~

~ Must
use header file guards.

```c
#ifndef sys_socket_h
#define sys_socket_h

/* Contents of sys/socket.h */

#endif /* sys_socket_h */
```
~

~ MustNot
use coding paradigms from other languages, including C++.  While C++ is a superset of C, using C++ constructs and style will confuse readers.
~

## Names

~ Must
make names fit.

Names are the heart of programming. In the past people believed knowing someone's true name gave them magical power over that person. If you can think up the true name for something, you give yourself and the people coming after power over the code. A name is the result of a long deep thought process about the ecology it lives in. Only a programmer who understands the system as a whole can create a name that "fits" with the system. If the name is appropriate everything fits together naturally, relationships are clear, meaning is derivable, and reasoning from common human expectations works as expected.

If you find all your names could be Thing and DoIt then you should probably revisit your design.
~

~ Must
use underbars ('_') to separate name components (snake-casing).
~

~ Should
use lower-case for all variable names that would be pushed onto the stack.  This assists with the identification of scope of the variable.
~

~ Must
use a single leading underscoe to indicate that a name is not part of the public API and is not guaranteed to be stable.
~

~ Must
place the `*` as close to the variable name to indicate a pointer type.  i.e. use `char *name = NULL;`, not `char* name = NULL;`.
~

~ Must 
include units in names.

If a variable represents time, weight, or some other unit then include the unit in the name so developers can more easily spot problems. For example:

```c
uint32 timeout_msecs;
uint32 my_weight_lbs;
```
~

~ Must
declare variables in structures organized by use in a manner to attempt to minimize memory wastage because of compiler alignment issues, then by size, and then by alphabetical order.

For example, don't use the following:

```c
struct foo {
    int a;
    char *b;
    int c;
    char *d;
};
```

Do use:

```c
struct foo {
    int a;
    int c;
    char *b;
    char *d;
};
```

Each variable get its own type and line, although an exception can be made when declaring bitfields (to clarify that it's part of the one bitfield).  The use of bitfields in general is discouraged.
~

~ Must
declare major structures at the top of the file in which they are used, or in separate header files if they are used in multiple source files.  Use of the structures should be by separate declarations should be "extern" if they are declared within a header file.
~

~ ToDo
Should we use a meaningful prefix for each member name or for structures in general?
~

~ MustNot
use global variables.  Global variables should be avoided whenever possible.  If required, prepend global variables with `g_`.
~

~ Must
name global constants using upper-case and snake-casing.  For example, `const in A_GLOBAL_CONSTANT = 5;`.

~ Must
name enum types using pascal-casing.  The values within an enum must be upper-case and snake-cased.  There must not be a comma on the last element.  

For example:

```c
enum PinStateType {
    PIN_OFF,
    PIN_ON
};
```
~

~ Must
be aware that enums are not of a guaranteed size.  If you have a type that can take a known range of values and it is transported in a message, you cannot use an enum as a type.
~

~ Must
make a label for an error state and make it the first label.  It is often useful to be able to say an enum is not in any of its valid states.

For example:

```c
enum ServiceState { 
    STATE_ERR, 
    STATE_OPEN, 
    STATE_RUNNING, 
    STATE_DYING 
};
```

## Macros

~ Must
name `#define` macros upper-case using snake-casing.  Macros are capitalized, parenthesized, and must avoid side-effects.  If the macro is an inline expansion of a function, the function is defined all in lowercase and the macro must have the same name in uppercase.  If the macro is an expression, wrap the expression in parenthesis.

Note: some subtle errors can occue when macro names and enum labels use the same name.

Examples:

```c
#define MAX(a,b) ((a > b) ? a : b)
#define IS_ERR(err) (err < 0)
```
~

~ Must
wrap a macro in `do { .... } while (0)` if the macro is more than a single statement, so that a trailing semicolon works.  Right-justify backslashes to ensure the macro is easier to read.

Example:

```c
#define MACRO(v, w, x, y)           \
do {                                \
    v = (x) + (y);                  \
    w = (y) + 2;                    \
} while (0)
```
~

~ MustNot
change syntax via macro substitution.  It [makes the program unintelligible](https://gist.github.com/aras-p/6224951) to all but the perpetrator.
~

~ Should
replace macros with inline functions.  In C, macros are not needed for code efficiency.  

Example, instead of `#define MAX(x,y) (((x) > (y) ? (x) : (y)))`, use the following:

```c
inline int max(int x, int y) { 
    return (x > y ? x : y);
}
```
~

~ Must
be careful of side effects in macros.  For example, using the following with the preceding macro would cause side effects:  `MAX(f(x),z++);`.
~

~ Must
wrap the macro expression in parenthesis.  This avoids potential communitive operation ambiguity.
~

~ Must
make macro names unique.  Like global variables, macros can conflict with macros from other packages.  Prepend macro names with package names, and avoid simple and common names like `MAX` and `MIN`.
~

## Formatting

~ Must
place the starting brace on the same line as the conditional or looping statement.  For example:

```c
if (condition) {
    ...
}

while (condition) {
    ...
}
```
~

~ Must
place all conditional or loop statements on one line, or add braces to identify the conditional/looping block.
~

~ Must
add comments to closing braces.  Adding a comment to closing braces can help when you are reading code because you don't have to find the begin brace to know what is going on.

```c
while (1) {
    if (valid) {
        ...
    } /* if valid */
    else {

    } /* not valid */
} /* end forever */
```

~ Should
consider screen size limits.  Most people like blocks to fit within a common screen size so scrolling is not necessary when reading code.  Lines should not exceed 78 characters, and blocks should not exceed 25 lines.
~

~ MustNot
put parens next to keywords.  Put a space between the keyword and the paren.
~

~ Must
put parens next to function names.
~

~ MustNot
use parens in return statements when it isn't necessary.
~

~ Must
place each segment of an `if`/`then`/`else` statement on a separate line if you have a block.  If you include `else if` statements, ensure you also add an `else` block for finding unhandled cases.

Example:

```c
if (valid) {
    ...
} /* if valid */
else {

} /* not valid */
```

~ Must
place the constant on the left hand side of an eqality/inequality comparison (yoda style).  For example, `if (6 == errNum) ...`.
~

~ Must
include a comment for falling through a `case` statement.
~

~ Must
include a `default` case when using a `switch` statement.
~

~ Must
place all code for a `case` statement in a block if you need to create variables.
~

Example of a switch statement:

```c
switch (...) {
    case 1:
        do_something();
        break;
    case 2:
        do_something_else();
        /* fall through */
    case 3: 
        {
            int v;

            do_something_more(v);
        }
        break;
    default:
        log(LOG_DEBUG, "default case reached");
}
```

~ ShouldNot
use `goto` statements.  The main place where `goto` statements can be usefully employed is to break out of several levels of `switch`, `for`, or `while` nesting, although the need to do such a thing may indicate that the inner constructs should be broken out into a separate function with a success/failure return code.  When a `goto` is necessary, the accompanying label should be alone on a line and to the left of the code that follows.  The `goto` should be commented as to its utility and purpose.
~

~ Should
use `continue` and `break` sparingly.  These statements are really disguised `goto` statements.
~

~ MustNot
use a ternary operator unless it is really clear what it does.  Put the condition in parens (so as to set it off from other code).  If possible, the actions for the test should be simple functions.  Put the action for the `then` and `else` statement on a separate line unless it can be clearly put on one line.
~

~ Must
place only one statement on each line.
~

## Complexity Management

~ Must
initialize all variables.  Use of compiler flags (such as `gcc -W`) may catch operations on uninitialized variables.
~

~ Must
limit function bodies to one page of code (25 lines, approximately).
~

~ Must
document null statements.  Always document a null body for a `for` or `while` statement so that it is clear the null body is intentional.
~

~ Must
use explicit comparisons when testing for failure.  Use `if (FAIL != f())` rather than `if (f())`.  Even though FAIL may have the value 0 which C considers to be false.  An explicit test will help you out later when somebody decides that a failure return should be -1 instead of 0.  

Explicit comparison should be used even if the comparison value will never change.  e.g. `if (!(bufsize % sizeof(int)))` should be written as `if (0 == (bufsize % sizeof(int))` to reflect the numeric (not boolean) nature of the test.  

A frequent trouble spot is using `strcmp` to test for string equality.  You should **never** use a default action.  The preferred approach is to use an inline function:

```c
inline bool string_equal(char *a, char *b) {
    return (strcmp(a, b) == 0);
}
```
~

~ Should
avoid embedded assignments.  There is a time and a place for embedded assignment statements.  In some constructs, there is no better way to accomplish the results without making the code bulkier and less readable.

```c
while (EOF != (c = getchar())) {
    /* process the character */
}
```

However, one should consider the tradeoff between increased speed and decreased maintainability that results when embedded assignments are used in artificial places.
~

## Miscellaneous

~ Should
avoid layering jumps.  

Layering is the primary technique for reducing complexity in a system.  A system should be divided into layers.  Layers should communicate between adjacent layers using well defined interfaces.  When a layer uses a non-adjacent layer, then a layering violation has occurred.  This means we have a dependency between layers that is not controlled by a well defined interface.  When one of the layers changes, code could break.  Sometimes we need to jump layers for performance reasons.  This is reasonable, but we should be explicit about it and document appropriately.
~

~ MustNot
use floating-point variables where discrete values are needed. Using a float for a loop counter is a great way to shoot yourself in the foot. Always test floating-point numbers as <= or >=, never use an exact comparison (== or !=).
~

~ MustNot
write around compiler bugs.  Compilers have bugs. Common trouble spots include structure assignment and bit fields. You cannot generally predict which bugs a compiler has. You could write a program that avoids all constructs that are known broken on all compilers. You won't be able to write anything useful, you might still encounter bugs, and the compiler might get fixed in the meanwhile. Thus, you should write ``around'' compiler bugs only when you are forced to use a particular buggy compiler.
~

~ MustNot
rely on automatic beautifiers. The main person who benefits from good program style is the programmer him/herself, and especially in the early design of handwritten algorithms or pseudo-code. Automatic beautifiers can only be applied to complete, syntactically correct programs and hence are not available when the need for attention to white space and indentation is greatest. Programmers can do a better job of making clear the complete visual layout of a function or file, with the normal attention to detail of a careful programmer (in other words, some of the visual layout is dictated by intent rather than syntax and beautifiers cannot read minds). Sloppy programmers should learn to be careful programmers instead of relying on a beautifier to make their code readable. Finally, since beautifiers are non-trivial programs that must parse the source, a sophisticated beautifier is not worth the benefits gained by such a program. Beautifiers are best for gross formatting of machine-generated code.
~

~ MustNot
use implicit assignment inside a test.  This is generally an accidental omission of the second `=` of the logical compare. The following is confusing and prone to error.
    
```c
if (abool = bbool) { ... }
```

Does the programmer really mean assignment here? Often yes, but usually no. The solution is to just not do it, an inverse Nike philosophy. Instead use explicit tests and avoid assignment with an implicit test. The recommended form is to do the assignment before doing the test:

```c
abool = bbool;
if (abool) { ... } 
```
~

~ Must
use the register sparingly to indicate the variables that you think are most critical.  Modern compilers will put variables in registers automatically.  In extreme cases, mark the 2-4 most critical values as `register` and mark the rest as `REGISTER`. The latter can be `#defined` to register on those machines with many registers.
~

~ Must
be `const` correct.  C provides the `const` keyword to allow passing as parameters objects that cannot change to indicate when a method doesn't modify its object. Using `const` in all the right places is called "const correctness." It's hard at first, but using `cons`t really tightens up your coding style. Const correctness grows on you.
~

~ Must
use `#if` instead of `#ifdef`.  Someone might write code like:

```c
#ifdef DEBUG
    temporary_debugger_break();
#endif
```

Someone else might compile the code with turned-of debug info like:

```c
cc -c lurker.cc -DDEBUG=0
```

Alway use `#if` if you have to use the preprocessor. This works fine, and does the right thing, even if `DEBUG` is not defined at all (!)

```c
#if DEBUG
    temporary_debugger_break();
#endif
```

If you really need to test whether a symbol is defined or not, test it with the `defined()` construct, which allows you to add more things later to the conditional without editing text that's already in the program:

```c
#if !defined(USER_NAME)
 #define USER_NAME "john smith"
#endif
```

~ Must
Use `#if` to comment out large code blocks.

Sometimes large blocks of code need to be commented out for testing.  The easiest way to do this is with an `#if 0` block:

```c
void example()
{
    great looking code

    #if 0
    lots of code
    #endif

    more code
}
```

You can't use `/**/` style comments because comments can't contain comments and surely a large block of your code will contain a comment, won't it?

Don't use `#ifdef` as someone can unknowingly trigger ifdefs from the compiler command line. 

`#if 0` is that even a day later you or anyone else has to know idea why this code is commented out. Is it because a feature has been dropped? Is it because it was buggy? It didn't compile? Can it be added back? It's a mystery.  Use descriptive macro names instead of `#if 0`

```c
#if NOT_YET_IMPLEMENTED  
#if OBSOLETE
#if TEMP_DISABLED
```

Always add a short comment explaining why it is commented out.
~

~ MustNot
put data definition in header files.  For example, this should be avoided:

```c
/* aheader.h */
int x = 0;
```

It's bad magic to have space consuming code silently inserted through the innocent use of header files.  It's not common practice to define variables in the header file, so it will not occur to developers to look for this when there are problems.  Consider, instead, defining the variable once in a source file and then use an `exten` statement to reference it.
~

~ MustNot
use magic nunmbers. A magic number is a bare naked number used in source code. It's magic because no-one has a clue what it means including the author inside 3 months. For example:

```c
if      (22 == foo) { start_thermo_nuclear_war(); }
else if (19 == foo) { refund_lotso_money(); }
else if (16 == foo) { infinite_loop(); }
else                { cry_cause_im_lost(); }
```

In the above example what do 22 and 19 mean? If there was a number change or the numbers were just plain wrong how would you know? Instead of magic numbers use a real name that means something. You can use `#define` or constants or enums as names. Which one is a design choice. For example:

```c
#define   PRESIDENT_WENT_CRAZY  (22)
const int WE_GOOFED= 19;
enum  {
   THEY_DIDNT_PAY= 16
};

if      (PRESIDENT_WENT_CRAZY == foo) { start_thermo_nuclear_war(); }
else if (WE_GOOFED            == foo) { refund_lotso_money(); }
else if (THEY_DIDNT_PAY       == foo) { infinite_loop(); }
else                                  { happy_days_i_know_why_im_here(); }
```

The `const` and `enum` options are preferable because when debugging the debugger has enough information to display both the value and the label. The `#define` option just shows up as a number in the debugger which is very inconvenient. The `const` option has the downside of allocating memory. Only you know if this matters for your application.
~

~ Must
check every system call for an error return, unless you know you wish to ignore errors. For example, `printf` returns an error code but rarely would you check for its return code. Ccast the return to (void) if you really do not care.

```c
(void)printf("The return type is ignored");
```
~

~ Must
include the system error text when reporting every system error message.
~

~ Must
check every call to `malloc` or `reallo`c unless you know your versions of these calls do the right thing. You might want to have your own wrapper for memory allocation calls, so you can do the right thing always and developers don't have to make memory checks everywhere.
~