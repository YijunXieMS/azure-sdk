### Error handling {#general-error-handling}

Error handling is an important aspect of implementing a client library.  It is the primary method by which problems are communicated to the consumer. Because we intend for the C client libraries
to be used on a wide range of devices with a wide range of reliability requirements, it's important to provide robust error handling.

We distinguish between several different types of errors:

* Pre-Conditions
    : Pre-Condition errors occur when a caller violates the expectations of a function, for example by passing an out-of-range value or a null pointer. These are always
      avoidable by the direct caller, and will always require a source code change (by the caller) to fix.
* Post-Conditions
    : Post-Condition violations happen when some function didn't do the correct thing, these are _always_ bugs in the function itself, and users shouldn't be
      expected to handle them.
* Exhaustion / Act of God
    : errors like running out of stack space, or dealing with power failure that, in general, can not be anticipated and after which it may be hard to execute any more code,
      let alone recover. Code handling these errors needs to be written to *very* specific requirements, for example not doing any allocations and never growing the stack. Or attempting
      to do a fast shutdown on UPS power.
* Recoverable Error
    : Things like trying to open a file that doesn't exist, or trying to write to a full disk. These kinds of errors can usually be handled by a function's caller directly, 
      and need to be considered by callers that want to be robust.

      
#### Pre Conditions

~ May
Check for the error with an assert, or similar
~

~ Should
Provide a user-settable callback function to be invoked upon a failed, checked precondition.

For example if you're implementing a client for the Azure Catherding API you might define:

```c
void az_catherding_default_panic_callback(void) {
  abort();
}
static thread_local void(*az_catherding_panic_callback)(void) = &az_catherding_default_panic_callback;
void az_catherding_set_panic_callback(void(*panic_callback)(void)) {
  az_catherding_panic_callback = panic_callback;
}

void az_catherding_panic() {
  az_catherding_panic_callback();
}
```

Note that it's important that the callback be thread local, since in some situations you *can* kill the thread and continue execution.
~

~ Must
By default, any failures in checked preconditions should trigger a program crash, with as much debugging information as feasible
~

~ May
Provide an option to disable any checks, and omit the code to preform them from built libraries/executables.
~

### Post Conditions

~ ShouldNot
Check preconditions in a way that changes the computational complexity of the function.
~

~ Must
Provide a way to omit post condition checks from the built library/executable.
~

### Exhaustion / Act of God

~ MustNot
Attempt to return an error to the caller
~

~ May
Attempt to crash, if possible
~

### Recoverable Error

Functions that may encounter a recoverable error should report it by way of 

### A Note on Out Of Memory

We all want to be able to handle low memory situations gracefully and effectively, and C is "helpful" in that
most memory allocation functions will return an error or nullpointer if they fail, including in the case of
"out of memory". If you need to allocate memory of a dynamic (user specified) size, or of an extremely large size, then
failures of that allocation should always be treated as a recoverable error. However for small, compile-time
constant sized allocations the decision of weather to treat a failure as an "Act of God" or a "Recoverable error" is more subtle
and should be decided when you start a new library (with ARB consultation).

On some platforms (mainly those that overcommit), it's extremely hard to handle OOM gracefully. Additionally if you are "almost"
out of memory and attempt to grow the stack (by calling functions, for example) then the system _MAY NOT TELL YOU_
and your program's state will be corrupted. Thus in order to be able to recover from out of memory errors the program needs to have bounded
stack size, and set the stacksize to the maximum value at the start of the program (because otherwise the stack could try and grow when you don't have any more memory). Additionally the library needs to never allocate anything on the OOM error handling path, and it probably needs to
have special code to try and free memory. 



~ Must
Provide an error code for each error that the client library can produce.  Provide a list of constants to allow easy identification of error conditions.
~

~ Must
include a clear indication of error conditions that a function can return, generally by returning `null` or `-1`.
~

~ Must
Provide a function that returns rich information about the last error generated by the client library.  Name this function `shortname_last_error()`, where shortname is the short name for your client library.  In the case of HTTP errors, this function must return the originating request (URL, query parameters, and headers) and response (status code and headers).
~

~ Must
Provide a function that returns the error code for the last error generated by the client library.  Name this function `shortname_last_error_code()`, where shortname is the short name for your client library.
~

~ Must
produce an error when any HTTP request fails with an HTTP status code that is not defined by the service/Swagger as a successful status code. These errors should also be logged as errors.
~

~ Must
document the errors that are produced by each method (with the exception of commonly thrown errors that are generally not documented in the target language).
~
