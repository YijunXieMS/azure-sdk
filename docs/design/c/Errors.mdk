### Error handling {#general-error-handling}

Error handling is an important aspect of implementing a client library. It is the primary method by which problems are communicated to the consumer. Because we intend for the C client libraries
to be used on a wide range of devices with a wide range of reliability requirements, it's important to provide robust error handling.

We distinguish between several different types of errors:

* Pre-Conditions
    : Pre-Condition errors occur when a caller violates the expectations of a function, 
      for example by passing an out-of-range value or a null pointer. These are always
      avoidable by the direct caller, and will always require a source code change (by the caller) to fix.
* Post-Conditions
    : Post-Condition violations happen when some function didn't do the correct thing, 
      these are _always_ bugs in the function itself, and users shouldn't be
      expected to handle them.
* Exhaustion / Act of God
    : errors like running out of stack space, or dealing with power failure that, 
      in general, can not be anticipated and after which it may be hard to execute any more code,
      let alone recover. Code handling these errors needs to be written to *very* specific requirements, 
      for example not doing any allocations and never growing the stack.
* Recoverable Error
    : Things like trying to open a file that doesn't exist, 
      or trying to write to a full disk. These kinds of errors can usually be handled by a function's caller directly, 
      and need to be considered by callers that want to be robust.


#### Pre Conditions

~ Should
Check preconditions with a contract macro. For example:

```
#ifdef INCLUDE_CONTRACTS
  #define CONTRACT_CHECK(x) \
    do {\
      if(!x) return az_panic_function();		\
    } while(0);
  #else
  #define CONTRACT_CHECK(x)
  #endif
  az_error some_unction(int some_arg) {
    CONTRACT_CHECK(some_arg > 0);
  }

```
~

~ Must
Call a "panic function" on a (checked) precondition failure. This function should be either provided 
by the user, or marked as a "weak symbol" if supported by the compiler.

For example

```c
az_error az_panic() {
  return AZ_ERROR_INVALID_ARGUMENT;
}
```
~

~ May
Provide an option to disable any checks, and omit checking code from built binaries.
~

~ Must
Document all function preconditions. For conditions like "not null", a `[not nullable]` annotation is satisfactory.
~

#### Post Conditions

~ ShouldNot
Check post-conditions in a way that changes the computational complexity of the function.
~

~ Must
Provide a way to disable postcondition checks, and omit checking code from built binaries.
~

#### Exhaustion / Act of God

~ MustNot
Return an error to the caller.
~

~ May
Crash, if possible.
~

Note: if your client library needs to be resilient to these kinds of errors
you must either provide a fallback system, or construct your code in a way
to facilitate proving that such errors can not occur.

#### Recoverable Error
~ Must
Report errors via an error code enum. The core library defines such an enum called `az_error`

For example:

```c
AZ_NODISCARD az_error az_catherding_count_cats(az_catherding_herd* herd, int* cats) {
  if(herd->has_shy_cats) {
    return AZ_ERROR_CATHERDING_HIDING_CATS;
  }
  *cats = herd->num_cats;
  return AZ_ERROR_SUCCESS;
}
```

~

~ Must
Mark all functions returning errors as `AZ_NODISCARD` this will cause supported compilers to emit a warning
if the caller ignores the error code.
~

~ Must
Return `AZ_ERROR_SUCCESS` from successful functions, unless the function has no error conditions.
~

~ Must
Produce a recoverable error when any HTTP request fails with an HTTP status code that is not defined by the service/Swagger as a successful status code.
~

~ Must
Document all recoverable errors each function generates.
~

#### A Note on Out Of Memory

We all want to be able to handle low memory situations gracefully and effectively, and C is "helpful" in that
most memory allocation functions return an error or null pointer if they fail, including in the case of
"out of memory". If you need to allocate memory of a dynamic (user specified) size, or of an extremely large size, then
failures of that allocation should always be treated as a recoverable error. However for small, compile-time
constant sized allocations the decision of weather to treat a failure as an "Act of God" or a "Recoverable error" is more subtle
and should be decided when you start a new library (with Architectural Review Board consultation).

On some platforms, mainly those that overcommit, it's extremely hard to handle OOM gracefully. Additionally, if you are "almost"
out of memory and attempt to grow the stack - by calling functions, for example - then the system _MIGHT NOT TELL YOU_
and your program's state will be corrupted. To recover from out of memory errors the program must have bounded
stack size and must set the stack size to that bound at the start of the program. Additionally, the library must not allocate on the OOM error handling path. 

